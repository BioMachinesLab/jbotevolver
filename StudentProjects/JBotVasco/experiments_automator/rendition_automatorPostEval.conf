%runs:1
%maxevolutions:1

--robots
 	classname=simulation.robot.AquaticDrone,
	rudder=1,
	distancewheels=0.2,
	enableRandomizenumber=1,
	randomizenumber=(3,4,5),
	radius=0.5,
	diameter=1,
	maxspeed=0.3,
	commrange=40,
	gpserror=1.8,
	compassoffset=0,
	compasserror=10,
	headingoffset=0.05,
	speedoffset=0.1,
	avoiddrones=0,
	sensors=(
		CISensorWrapper_1=(
			classname=simulation.robot.CISensorWrapper,
			ci=(
				classname=commoninterface.sensors.InfiniteTargetCISensor,
				id=1,
				linear=1,
				normalize=1,
				range=40
			),
			id=1
		),
		CISensorWrapper_2=(
			classname=simulation.robot.CISensorWrapper,
			ci=(
				classname=commoninterface.sensors.TargetMotionCISensor,
				id=2,
				normalize=1,
				range=40
			),
			id=2
		),
		CISensorWrapper_3=(
			classname=simulation.robot.CISensorWrapper,
			ci=(
				classname=commoninterface.sensors.DroneCISensor,
				id=3,
				range=40,
				numbersensors=4
			),
			id=3
		),
       	CISensorWrapper_4=(
           classname=simulation.robot.CISensorWrapper,
        	ci=(
        		classname=commoninterface.sensors.CompassCISensor,
        		id=4,
        		normalize=1
        	),
        	id=4
        )
	)
	
--controllers
 	classname=controllers.DroneNeuralNetworkController,
	network=(
		classname=commoninterface.neuralnetwork.CINEATNetwork,
		inputs=(
			TargetLocation=(
				classname=commoninterface.neuralnetwork.inputs.GenericCINNInput,
				label=TargetLocation,
				id=1
			),
			TargetMotion=(
				classname=commoninterface.neuralnetwork.inputs.GenericCINNInput,
				label=TargetMotion,
				id=2
			),
			Drone=(
				classname=commoninterface.neuralnetwork.inputs.GenericCINNInput,
				label=DroneSensor,
				id=3
			),
            Compass=(
                classname=commoninterface.neuralnetwork.inputs.GenericCINNInput,
                label=CompassSensor,
                id=4
            )
        ),
		outputs=(
			Rudder=(
				classname=commoninterface.neuralnetwork.outputs.RudderCINNOutput,
				label=Rudder,
				forwardonly=1,
				id=1
			)
		)
	)
	

--simulator network=(classname=network.SimulationNetwork)
--executor classname=taskexecutor.ParallelTaskExecutor
--evolution 
	classname=evolutionaryrobotics.evolution.NEATEvolution,
	task=(
		classname=taskexecutor.tasks.TargetGenerationalTask
	)

--evaluation
 	classname=evolutionaryrobotics.evaluationfunctions.KeepPositionInTargetSimpleEvaluationFunctionClean,
	dontuse=0,
	safetyDistance=3,
	kill=1,
	energyOnly=0

--environment
 	classname=environment.target.FormationMultiTargetEnvironment,
 	
	width=75,
	height=75,
	steps=2000,

	radiusOfObjectPositioning=15,
	onePerOneRobotTarget=1,
	variateTargetsQnt=0,
	targetRadius=1.5,
	safetyRandomPositionDistance=3.5,
	faultDuration=500,
	injectFaults=0,

	formationShape=random,
	lineFormation_xDelta=6.0,
	arrowFormation_xDelta=6.0,
	arrowFormation_yDelta=6.0,
	circleFormation_radius=10,
	variateFormationParameters=0,

	moveTarget=1,
	targetMovementVelocity=0.2,
	variateTargetsSpeed=1,
	targetMovementAzimuth=0,
	variateTargetsAzimuth=1,
	
	rotateFormation=1,
	rotationVelocity=0.015,
	rotationDirection=0,
	variateRotationVelocity=1,
	variateRotationDirection=1
	
--updatables 
	currents=(
		classname=updatables.WaterCurrent,
		maxspeed=0.1
	)
	
--postevaluation
	dir=./experiments_automator/rendition_automatorPostEval/rendition_DEBUG_newSensor_orientation,
	samples=6,
	targetfitness=0,
	singleEvaluation=0,
	sampleincrement=1,
	steps=4000,
	showOutput=1,
	saveOutput=1,
	localevaluation=1
		
%pop{
	--population
 		classname=evolutionaryrobotics.populations.NEATPopulation,
		samples=1,
		generations=600,
		size=150
}

#rendition_DEBUG_newSensor_orientation{
	%pop
	--evaluation +energyOnly=0
}